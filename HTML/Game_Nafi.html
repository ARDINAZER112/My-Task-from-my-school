<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Platformer Mobile (HTML5)</title>
  <style>
    /* Reset & layout */
    html,body{height:100%;margin:0;background:#101217;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #gameWrap{position:relative;width:100%;height:100vh;overflow:hidden;background:linear-gradient(#87ceeb,#5b86e5)}
    canvas{display:block;margin:0 auto;background:transparent}

    /* Touch controls */
    .btn{position:fixed;bottom:18px;touch-action:none;user-select:none;-webkit-user-select:none;background:rgba(0,0,0,0.25);backdrop-filter:blur(4px);border-radius:12px;padding:12px;font-weight:700}
    #left{left:18px}
    #right{left:96px}
    #jump{right:18px}
    .btn:active{transform:scale(0.98)}

    /* HUD */
    #hud{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px}
    #hint{position:fixed;left:50%;transform:translateX(-50%);top:12px;background:rgba(0,0,0,0.2);padding:6px 12px;border-radius:8px}

    /* Mobile-friendly larger hit area for small devices */
    @media (max-width:420px){.btn{padding:16px;border-radius:16px}}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game"></canvas>
    <div id="hud">Score: <span id="score">0</span></div>
    <div id="hint">Gunakan tombol kiri/kanan dan lompat — atau keyboard A/D/←/→/Space</div>

    <!-- Touch buttons -->
    <div id="left" class="btn">◀</div>
    <div id="right" class="btn">▶</div>
    <div id="jump" class="btn">▲</div>
  </div>

  <script>
    // Mobile-friendly HTML5 platformer
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = canvas.width = Math.min(window.innerWidth, 900);
    let H = canvas.height = Math.min(window.innerHeight, 640);

    // scale for different screens
    function resize(){
      W = canvas.width = Math.min(window.innerWidth, 900);
      H = canvas.height = Math.min(window.innerHeight, 640);
    }
    window.addEventListener('resize', resize);

    // --- Game variables ---
    const gravity = 1400; // px/s^2
    const TILE = 48;

    // player
    const player = {
      x: 80, y: 0, w: 36, h: 44,
      vx: 0, vy: 0,
      speed: 300,
      jumpPower: 520,
      onGround: false,
      color: '#ffdd57'
    };

    let keys = {left:false,right:false,jump:false};
    let score = 0;

    // simple tile-based level (array of strings)
    const level = [
      '                                                                                ',
      '                                                                                ',
      '                                                                                ',
      '                                                                                ',
      '                                                                                ',
      '                                                                                ',
      '                                                                                ',
      '                                                                                ',
      '           c                                      c                             ',
      '                                                                                ',
      '    ---                     =         ccc                                    cc ',
      '====================   =========   ==========================  ================='
    ];

    // convert to rectangles
    const platforms = [];
    const coins = [];
    function buildLevel(){
      platforms.length = 0; coins.length = 0;
      for(let r=0;r<level.length;r++){
        const row = level[r];
        for(let c=0;c<row.length;c++){
          const ch = row[c];
          const x = c * TILE; const y = r * TILE + (H - level.length*TILE);
          if(ch === '=' ) platforms.push({x,y,w:TILE,h:TILE});
          if(ch === 'c') coins.push({x:x+TILE/2-10,y:y+TILE/2-10,w:20,h:20, taken:false});
          if(ch === '-') platforms.push({x,y,w:TILE,h:TILE});
        }
      }
    }

    // camera
    const camera = {x:0,y:0};

    // build
    buildLevel();

    // helpers
    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // input handlers
    window.addEventListener('keydown', e=>{
      if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left=true;
      if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right=true;
      if(e.key === ' ' || e.key === 'Spacebar') keys.jump=true;
    });
    window.addEventListener('keyup', e=>{
      if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left=false;
      if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right=false;
      if(e.key === ' ' || e.key === 'Spacebar') keys.jump=false;
    });

    // touch buttons
    function touchStartHandler(button){
      return function(e){
        e.preventDefault();
        if(button==='left') keys.left=true;
        if(button==='right') keys.right=true;
        if(button==='jump') keys.jump=true;
      }
    }
    function touchEndHandler(button){
      return function(e){
        e.preventDefault();
        if(button==='left') keys.left=false;
        if(button==='right') keys.right=false;
        if(button==='jump') keys.jump=false;
      }
    }
    document.getElementById('left').addEventListener('touchstart', touchStartHandler('left'));
    document.getElementById('left').addEventListener('touchend', touchEndHandler('left'));
    document.getElementById('right').addEventListener('touchstart', touchStartHandler('right'));
    document.getElementById('right').addEventListener('touchend', touchEndHandler('right'));
    document.getElementById('jump').addEventListener('touchstart', touchStartHandler('jump'));
    document.getElementById('jump').addEventListener('touchend', touchEndHandler('jump'));

    // also support pointer events for mouse
    ['mousedown','mouseup'].forEach(ev=>{
      document.getElementById('left').addEventListener(ev, e=>{keys.left = ev==='mousedown'});
      document.getElementById('right').addEventListener(ev, e=>{keys.right = ev==='mousedown'});
      document.getElementById('jump').addEventListener(ev, e=>{keys.jump = ev==='mousedown'});
    });

    // main loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.032, (now - last) / 1000);
      update(dt);
      render();
      last = now;
      requestAnimationFrame(loop);
    }

    function update(dt){
      // horizontal input
      let targetVx = 0;
      if(keys.left) targetVx = -player.speed;
      if(keys.right) targetVx = player.speed;
      // smooth accel
      const accel = 3000;
      player.vx += (targetVx - player.vx) * Math.min(1, accel * dt / Math.abs(targetVx - player.vx || 1));

      // jumping
      if(keys.jump && player.onGround){
        player.vy = -player.jumpPower;
        player.onGround = false;
      }

      // apply gravity
      player.vy += gravity * dt;

      // integrate
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // simple world bounds
      if(player.y > H + 200){ // fell off
        respawn();
      }

      // collisions with platforms (AABB) - simple axis separation
      player.onGround = false;
      for(const p of platforms){
        const box = {x:p.x, y:p.y, w:p.w, h:p.h};
        if(rectsOverlap(player, box)){
          // find smallest penetration axis
          const px = (player.x + player.w/2) - (box.x + box.w/2);
          const py = (player.y + player.h/2) - (box.y + box.h/2);
          const overlapX = (player.w + box.w)/2 - Math.abs(px);
          const overlapY = (player.h + box.h)/2 - Math.abs(py);
          if(overlapX < overlapY){
            // push horizontally
            if(px > 0) player.x += overlapX; else player.x -= overlapX;
            player.vx = 0;
          } else {
            // push vertically
            if(py > 0){ player.y += overlapY; player.vy = 0; }
            else { player.y -= overlapY; player.vy = 0; player.onGround = true; }
          }
        }
      }

      // coin collection
      for(const c of coins){
        if(!c.taken && rectsOverlap(player,{x:c.x,y:c.y,w:c.w,h:c.h} )){
          c.taken = true; score += 10; document.getElementById('score').textContent = score;
        }
      }

      // camera follows player (clamped)
      camera.x = player.x - W/2 + player.w/2;
      camera.y = 0; // static vertical camera for simplicity
      if(camera.x < 0) camera.x = 0;
      // max level width
      const levelWidth = level[0].length * TILE;
      if(camera.x > levelWidth - W) camera.x = Math.max(0, levelWidth - W);
    }

    function respawn(){
      player.x = 80; player.y = 0; player.vx = 0; player.vy = 0; score = 0;
      for(const c of coins) c.taken = false;
      document.getElementById('score').textContent = score;
    }

    function render(){
      ctx.clearRect(0,0,W,H);

      // background parallax
      ctx.fillStyle = '#7ec0ee';
      ctx.fillRect(0,0,W,H);

      // draw platforms
      ctx.save();
      ctx.translate(-camera.x, -camera.y);
      for(const p of platforms){
        ctx.fillStyle = '#6b5b3a';
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(p.x,p.y,p.w,p.h);
      }

      // draw coins
      for(const c of coins){
        if(c.taken) continue;
        ctx.beginPath();
        ctx.fillStyle = '#ffd95b';
        ctx.ellipse(c.x + c.w/2, c.y + c.h/2, c.w/2, c.h/2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();
      }

      // draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.w, player.h);
      // simple eye
      ctx.fillStyle = '#111'; ctx.fillRect(player.x + player.w - 14, player.y + 10, 6, 6);

      ctx.restore();

      // debug / HUD could be drawn here
    }

    // start loop
    requestAnimationFrame(loop);

    // initial player placement on top of first platform if available
    function placeOnTop(){
      // try to place player near start x
      player.y = 0;
      // let physics settle for a moment (optional)
    }
    placeOnTop();

    // tweak: support tapping anywhere to jump (optional)
    canvas.addEventListener('touchstart', e=>{
      if(e.touches.length === 1){ keys.jump = true; setTimeout(()=>keys.jump=false, 150); }
    });

    // friendly hint hide on play
    document.getElementById('hint').addEventListener('touchstart', ()=>{document.getElementById('hint').style.display='none'});

  </script>
</body>
</html>
